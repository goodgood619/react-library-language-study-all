## 오래된 var

---

var은 let으로 선언한 변수와 유사합니다. 

그러나, 다음과 같은 차이점이 존재합니다.

1. var은 블록 스코프가 없습니다. 함수 스코프이거나 전역 스코프만 존재합니다.
2. 선언하기전에 사용 할 수 있습니다.

<br><br><br>

먼저 1번의 경우는 다음과 같은 예제를 확인 해볼 수 있습니다.

```jsx
if (true) {
  var test = true; // 'let' 대신 'var'를 사용했습니다.
}

alert(test); // true(if 문이 끝났어도 변수에 여전히 접근할 수 있습니다)
```

if문이라는 블록내부에서 test값이 변수가 선언이 되었지만, 그 블록을 벗어난 후에도 여전히 test에 접근을 할 수 있습니다. 이 경우는 함수 스코프가 아니므로, 전역 스코프의 경우라 볼 수 있습니다.

<br><br>

또한 반복문의 경우에서도 이와 같은 현상은 나타 날 수 있습니다

```jsx
for (var i = 0; i < 10; i++) {
  // ...
}

alert(i); // 10, 반복문이 종료되었지만 'i'는 전역 변수이므로 여전히 접근 가능합니다.
```

<br><br>

함수 스코프의 예로 든다면 다음과 같은 예제가 있을 수 있습니다.

```jsx
function sayHi() {
  if (true) {
    var phrase = "Hello";
  }

  alert(phrase); // 제대로 출력됩니다.
}

sayHi();
alert(phrase); // Error: phrase is not defined
// 왜냐하면, sayHi 내부의 함수 단위에서 선언이 되었기 때문입니다.
```

<br><br><br>


### Hoisting

---

2번의 경우는 함수 본문 내에서 var로 선언한 변수가 선언 위치와 상관없이 **함수 본문이 시작되는 지점에서 정의됩니다.**(단, 변수가 중첩 함수 내에서 정의되지 않아야 이 규칙이 적용됩니다)

단 할당이 된 경우는 예외입니다.

```jsx
function sayHi() {
  phrase = "Hello"; // 할당을 해줍니다.

  alert(phrase); // 변수의 선언이 alert문보다 늦었지만,
 // 이미 할당된 phrase변수에 Hello가 출력이 됩니다.

  var phrase; // 선언이 alert문보다 나중에 되었습니다.
}
sayHi();
```

마치 선언된 변수가 이미 위로 끌어올라 간것 같은 현상이 나타납니다. 

이것을 **호이스팅(Hoisting)**이라고 부릅니다.

그리고 var이 블록 스코프가 존재 하지 않기 때문에, 블록 스코프를 가질수 있게 하게 하기 위한 방안을 중에 즉시 실행 함수 표현식이라는 것이 있습니다.


<br><br>

### 즉시 실행 함수 표현식

---

**즉시 실행 함수 표현식**은 다음과 같이 생겼습니다.

```jsx
(function() {

  let message = "Hello";

  alert(message); // Hello

})();
```

<br><br>

함수 선언문을 괄호로 둘러쌓아 (function {…})와 같은 형태로 만듭니다. 이렇게 괄호로 둘러싸지 않으면 에러가 발생합니다. 왜냐하면, 함수의 이름이 있어야 하기 때문입니다.

```jsx
function() {

  let message = "Hello";

  alert(message); // Hello

}(); // 이런 경우는 괄호로 둘러쌓지 않았으므로 문법적 오류가 납니다.
```

<br><br>

그러나, 함수의 이름이라는 개념을 오해해 함수에 이름을 붙이라는 의미는 아닙니다.

```jsx
// 맨 아래의 괄호 때문에 문법 에러가 발생합니다.
function go() {

}(); // <-- 함수 선언문은 선언 즉시 호출할 수 없습니다.
// 왜냐하면, 함수 선언문은 런타임시에 호출이 되기 때문입니다.
```

그래서, 함수 선언문에 ()를 붙이게 되면 함수 표현식으로 속여서 즉시 실행을 할 수 있게 만들 수 있습니다.